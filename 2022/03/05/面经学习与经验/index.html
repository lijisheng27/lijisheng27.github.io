<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

  <meta name="description" content="title:面经学习及经验1 data1.1 一面 50min 自我介绍+项目介绍 15min  1.1.1 Coding 5min有序矩阵查找        题解 将矩阵逆时针旋转45度，发现其类似于二叉搜索树，对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从“根节点”开始搜索，遇到比target大的元素就向左，反之向右。 “根节点”对应为矩阵“左下角”或“右上角”元素，以左下角为">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2022/03/05/%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%BB%8F%E9%AA%8C/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="title:面经学习及经验1 data1.1 一面 50min 自我介绍+项目介绍 15min  1.1.1 Coding 5min有序矩阵查找        题解 将矩阵逆时针旋转45度，发现其类似于二叉搜索树，对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从“根节点”开始搜索，遇到比target大的元素就向左，反之向右。 “根节点”对应为矩阵“左下角”或“右上角”元素，以左下角为">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic4.zhimg.com/v2-3baa8ea48cf7028510871a2894ffbb97_r.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210228220023518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc4MDg4MA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210228222931495.png">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=M">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=y_%7Bic%7D">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=0">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=1">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=i">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=c">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=1">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=0">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=p_%7Bic%7D">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=i">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=c">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/153/1.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/154/1.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/154/4.png">
<meta property="article:published_time" content="2022-03-04T16:18:52.130Z">
<meta property="article:modified_time" content="2022-03-04T16:29:04.455Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic4.zhimg.com/v2-3baa8ea48cf7028510871a2894ffbb97_r.jpg">


<link rel="canonical" href="http://example.com/2022/03/05/%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%BB%8F%E9%AA%8C/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2022/03/05/%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%BB%8F%E9%AA%8C/","path":"2022/03/05/面经学习与经验/","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title> | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#title-%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%BB%8F%E9%AA%8C"><span class="nav-number">1.</span> <span class="nav-text">title:面经学习及经验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-data"><span class="nav-number">2.</span> <span class="nav-text">1 data</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%B8%80%E9%9D%A2-50min"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 一面 50min</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-Coding-5min"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1.1 Coding 5min</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E6%8F%90%E9%97%AE"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.1.2 提问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-Coding-10min"><span class="nav-number">2.1.3.</span> <span class="nav-text">1.1.3 Coding 10min</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-4-%E6%8F%90%E9%97%AE"><span class="nav-number">2.1.4.</span> <span class="nav-text">1.1.4 提问</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%BA%8C%E9%9D%A2-50min"><span class="nav-number">2.2.</span> <span class="nav-text">1.2 二面 50min</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.2.1 自我介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-Coding"><span class="nav-number">2.2.2.</span> <span class="nav-text">1.2.2 Coding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E6%A6%82%E7%8E%87%E9%A2%98"><span class="nav-number">2.2.3.</span> <span class="nav-text">1.2.3 概率题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-AI-LAB-NLP"><span class="nav-number">3.</span> <span class="nav-text">2 AI LAB NLP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%B8%80%E9%9D%A2"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 一面</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E6%8F%90%E9%97%AE"><span class="nav-number">3.1.1.</span> <span class="nav-text">2.1.1 提问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-coding"><span class="nav-number">3.1.2.</span> <span class="nav-text">2.1.2 coding</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E4%BA%8C%E9%9D%A2"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 二面</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E6%8F%90%E9%97%AE"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.2.1 提问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-Coding"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2.2 Coding</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-data-%E5%B9%BF%E5%91%8A%E7%AE%97%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">3 data-广告算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%B8%80%E9%9D%A2"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 一面</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E6%8F%90%E9%97%AE"><span class="nav-number">4.1.1.</span> <span class="nav-text">3.1.1 提问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-Coding"><span class="nav-number">4.1.2.</span> <span class="nav-text">3.1.2 Coding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86"><span class="nav-number">4.1.3.</span> <span class="nav-text">3.1.3 高频算法题整理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">剑指 Offer 48. 最长不含重复字符的子字符串</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%98%BF%E9%87%8C"><span class="nav-number"></span> <span class="nav-text">阿里</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%B9%BF%E5%91%8A"><span class="nav-number">1.</span> <span class="nav-text">1 广告</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%B8%80%E9%9D%A2%EF%BC%8870min%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 一面（70min）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1coding"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1coding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E6%8F%90%E9%97%AE-1"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2 提问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E7%9C%9F%E9%A2%98%E7%BB%83%E4%B9%A0"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.2 真题练习</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%85%BE%E8%AE%AF"><span class="nav-number"></span> <span class="nav-text">腾讯</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-PCG%E6%89%8B%E6%B8%B8%E6%8E%A8%E8%8D%90"><span class="nav-number">1.</span> <span class="nav-text">1 PCG手游推荐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%B8%80%E9%9D%A2-60min"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 一面 60min</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-Coding-20min"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1 Coding 20min</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E6%8F%90%E9%97%AE-2"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2 提问</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%BA%8C%E9%9D%A2-60min"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 二面 60min</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/05/%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%BB%8F%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-03-05 00:18:52 / Modified: 00:29:04" itemprop="dateCreated datePublished" datetime="2022-03-05T00:18:52+08:00">2022-03-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <hr>
<h2 id="title-面经学习及经验"><a href="#title-面经学习及经验" class="headerlink" title="title:面经学习及经验"></a>title:面经学习及经验</h2><h2 id="1-data"><a href="#1-data" class="headerlink" title="1 data"></a>1 data</h2><h3 id="1-1-一面-50min"><a href="#1-1-一面-50min" class="headerlink" title="1.1 一面 50min"></a>1.1 一面 50min</h3><ul>
<li>自我介绍+项目介绍 15min</li>
</ul>
<h4 id="1-1-1-Coding-5min"><a href="#1-1-1-Coding-5min" class="headerlink" title="1.1.1 Coding 5min"></a>1.1.1 Coding 5min</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sorted-matrix-search-lcci/">有序矩阵查找</a>        <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/">题解</a></p>
<p>将矩阵逆时针旋转45度，发现其类似于二叉搜索树，对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从“根节点”开始搜索，遇到比target大的元素就向左，反之向右。</p>
<p>“根节点”对应为矩阵“左下角”或“右上角”元素，以左下角为“根节点”，记为标志树flag。</p>
<p>从矩阵 matrix 左下角元素（索引设为 (i, j) ）开始遍历，并与目标值对比：<br>当 matrix[i][j] &gt; target 时，执行 i– ，即消去第 i 行元素；<br>当 matrix[i][j]&lt; target 时，执行 j++ ，即消去第 j 列元素；<br>当 matrix[i][j] &#x3D; target 时，返回 true ，代表找到目标值。<br>若行索引或列索引越界，则代表矩阵中无目标值，返回 false。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = matrix.<span class="built_in">size</span>() - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &gt; target) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-提问"><a href="#1-1-2-提问" class="headerlink" title="1.1.2 提问"></a>1.1.2 提问</h4><ul>
<li><strong>有哪些优化器</strong>？（Adam，Adagrad，SGD）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/111932438">参考链接1</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/flix/p/13144064.html">参考链接2</a></p>
<p>在训练模型时，我们可以基于梯度使用不同的优化器（optimizer，或者称为“优化算法”）来最小化损失函数。</p>
<p><strong>SGD(随机梯度下降)</strong></p>
<p>$\theta \leftarrow \theta - \alpha \nabla_\theta L $</p>
<p><strong>AdaGrad( adaptive gradient)</strong></p>
<p>通过过往的梯度g累积，自动调节学习率。</p>
<p>梯度累积：$r \leftarrow r+ g <em>g$，</em>是逐个元素乘积的意思。</p>
<p>自适应学习率：$\alpha \leftarrow \frac{\alpha}{\delta + \sqrt{r}}$</p>
<p>更新方式:$\theta \leftarrow \theta - \alpha \nabla_\theta L $</p>
<p><strong>Adam</strong></p>
<p>使用梯度的指数加权平均（一阶矩估计）和梯度平方的指数加权平均（二阶矩估计）来动态地调整每个参数的学习率。</p>
<p>$m_t &#x3D; \beta m_{t-1} + (1-\beta)g_t$</p>
<p>$n_t&#x3D;\gamma n_{t-1}+(1-\gamma)g_t^2$</p>
<p>其中，$m_t$是梯度的指数加权平均（一阶矩估计），$n_t$是梯度平方的指数加权平均（二阶矩估计）。</p>
<ul>
<li><p><strong>Adam的二阶矩怎么近似的？（不会）</strong></p>
</li>
<li><p><strong>防止过拟合的技术？</strong>（ dropout，BN，LN）</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3ec2c55d93a5?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">参考链接</a></p>
<p>过拟合，训练出来的模型在训练集上表现很好（准确率很高），但在测试集上的准确率比较差，即过度学习了训练集上的特征，导致泛化能力较差。</p>
<p><strong>hold out 方法</strong>（提前停止）</p>
<p>把训练集分为训练集和验证集，其中训练集用来训练数据，验证集用来检测准确率。在每个迭代期的最后都计算在验证集上的分类准确率，一旦分类准确率已经饱和，就停止训练。这个策略被称为提前停止。</p>
<p><strong>增大训练量</strong></p>
<p><strong>人为扩展训练数据</strong></p>
<p><strong>规范化（regularization）</strong></p>
<p><strong>L2规范化</strong></p>
<p>增加一个额外的项到代价函数上，这个项被称为规范化项。</p>
<p>$C&#x3D;C_0+\frac{\lambda}{2n}\sum_\omega \omega^2$</p>
<p>规范化的效果是让网络倾向于学习小一点的权重</p>
<p><strong>L1规范化</strong></p>
<p>$C&#x3D;C_0+\frac{\lambda}{n}\sum_\omega |\omega|$</p>
<p>当一个特定的权重绝对值$|\omega|$很大时，L1规范化的权重缩小远比L2小很多；当$|\omega|$很小时，L1的缩小比L2大很多。</p>
<p><strong>dropout</strong></p>
<p>不改变网络本身，会随机地删除网络中的一般隐藏的神经元，并且让输入层和输出层的神经元保持不变。</p>
<ul>
<li><strong>Wide&amp;Deep模型细节</strong></li>
</ul>
<p>与广义的搜索排序问题一样，推荐系统也面临这样一个挑战：如何同时实现记忆与泛化（memorization and generation）。记忆可理解为，学习并利用历史数据中的高频共现物体或特征所具有的关系。泛化指这一关系的转移能力，以及发现在历史数据中罕见或未曾出现过的新的特征组合。</p>
<p>wide&amp;deep模型包括两个部分，分别为wide模型和deep模型。结合线性模型的记忆能力（memorization）和 DNN 模型的泛化能力（generalization），在训练过程中同时优化 2 个模型的参数，从而达到整体模型的预测能力最优。<br>记忆（memorization）即从历史数据中发现item或者特征之间的相关性。<br>泛化（generalization）即相关性的传递，发现在历史数据中很少或者没有出现的新的特征组合。</p>
<p><strong>Wide部分</strong></p>
<p>基础的线性模型，表示为$y&#x3D;\omega x+b$，x特征部分包括基础特征和交叉特征。交叉特征可以捕捉到特征间的交互，起到添加非线性的作用。</p>
<p><strong>Deep部分</strong></p>
<p>前馈网络模型，特征首先转化为低维稠密向量。向量随机初始化，经过最小化损失函数训练模型，激活函数采用Relu。</p>
<h4 id="1-1-3-Coding-10min"><a href="#1-1-3-Coding-10min" class="headerlink" title="1.1.3 Coding 10min"></a>1.1.3 Coding 10min</h4><p> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">找链表中点</a></p>
<p>单指针法</p>
<p>对链表进行两次遍历，第一次遍历时，统计链表元素个数N；第二次遍历时，遍历到N&#x2F;2元素时，返回该元素。</p>
<p>快慢指针法</p>
<p>两个指针slow与fast一起遍历链表。slow一次走一步，fast一次走两步。当fast到达链表的末尾时，slow必然位于中间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/UHnkqh/">链表原地翻转</a></p>
<p>迭代</p>
<p>遍历链表时，将当前节点的next指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用前，还需要存储后一个节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            ListNode* next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/LGjMqU/">重排链表</a></p>
<p>线性表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;ListNode *&gt; vec;</span><br><span class="line">        ListNode *node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(node);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = vec.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            vec[i]-&gt;next = vec[j];</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vec[j]-&gt;next = vec[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[i]-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>寻找链表中点 + 链表逆序 + 合并链表</p>
<h4 id="1-1-4-提问"><a href="#1-1-4-提问" class="headerlink" title="1.1.4 提问"></a>1.1.4 提问</h4><ul>
<li><strong>详细介绍NDCG</strong></li>
</ul>
<p>归一化折损累计增益，关心找到的项目是否放在用户更显眼的位置里，强调“顺序性）</p>
<p><strong>CG</strong> 累计增益</p>
<p>只考虑相关性的关联程度，没有考虑到位置的因素。</p>
<p>$CG &#x3D; \sum_{i&#x3D;1}^{p} rel_i$</p>
<p>$rel_i$代表i这个位置上的相关度，{0,1}(可以时实数的形式)</p>
<p><strong>DCG</strong> 折损累计增益</p>
<p>$DCG &#x3D; \sum_{i&#x3D;1}^p \frac{rel_i}{log_2(i+1)}$</p>
<p>增加相关度影响比重的DCG</p>
<p>$DCG &#x3D; \sum_{i&#x3D;1}^p \frac{2^{rel_i}}{log_2(i+1)}$</p>
<p><strong>NDCG</strong> 归一化折损累计增益</p>
<p>$NDCG &#x3D; \frac{DCG}{IDCG}$</p>
<p>IDCG为理想情况下最大的DCG值</p>
<p>$IDCG &#x3D; \sum_{i&#x3D;1}^{|REL|} \frac{2^{rel_i}}{log_2(i+1)}$</p>
<p>其中|REL|表示，结果按照相关性从大到小的顺序排序，取p个结果组成的集合，即按照最优的方式对结果进行排序。</p>
<ul>
<li><strong>二分类指标？（ AP，mAP，P&#x2F;R）</strong></li>
</ul>
<p><strong>准确率 Accuracy</strong></p>
<p>分类正确的样本数占总样本数的比例</p>
<p>TP：True Positive， 把正类预测为正类；</p>
<p>FP：False Positive，把负类预测为正类；</p>
<p>TN：True Negative， 把负类预测为负类；</p>
<p>FN：False Negative，把正类预测为负类</p>
<p><strong>精确率 Precision</strong></p>
<p>精确率是指在预测为正类的样本中真正类所占的比例</p>
<p>$P&#x3D;\frac{TP}{TP+FP}$</p>
<p><strong>召回率 Recall</strong></p>
<p>所有的正类中被预测为正类的比例</p>
<p>$R &#x3D; \frac{TP}{TP+FN}$</p>
<p><strong>F1-Score</strong></p>
<p>$\frac{2}{F1}&#x3D;\frac{1}{P}+\frac{1}{R}$</p>
<p><strong>ROC 曲线和 AUC</strong></p>
<p>TPR：True Positive Rate，真正率，代表能将正例分对的概率</p>
<p>$TPR&#x3D;\frac{TP}{TP+FN}$</p>
<p>FPR: False Positive Rate, 假正率，代表将负例错分为正例的概率</p>
<p>$FPR&#x3D;\frac{FP}{FP+TN}$</p>
<p>使用FPR作为横坐标，TPR作为纵坐标得到ROC曲线。ROC曲线越靠近左上角，该分类器的性能越好。</p>
<p><strong>AUC</strong>（Area under roc curveROC）</p>
<p>曲线下的面积，AUC的面积越大，分类效果越好。表征了分类器把正样本排在负样本前面的能力。</p>
<p>n为样本数（即n&#x3D;M+N）,M为正类样本的数目，N为负类样本的数目</p>
<p>从统计意义去计算，所有正负样本中，有多少组中的正样本score大于负样本score的概率。</p>
<p>时间复杂度为O(n^2)</p>
<p>首先对score从大到小排序，然后另最大score对应的sample的rank为n，第二大score对应的rank为n-1。然后把所有的正类样本的rank相加，再减去两个正样本组合的情况。</p>
<p>$AUC&#x3D;\frac{\sum_{i \in positiveClass}rank_i - \frac{M(1+M)}{2}}{M\times N}$</p>
<p>为了求的组合中正样本的score值大于负样本，如果所有的正样本score值都是大于负样本的，那么第一位与任意的进行组合score值都要大，我们取它的rank值为n，但是n-1中有M-1是正样例和正样例的组合这种是不在统计范围内的（为计算方便我们取n组，相应的不符合的有M个），所以要减掉，那么同理排在第二位的n-1，会有M-1个是不满足的，依次类推，故得到后面的公式M*(M+1)&#x2F;2，我们可以验证在正样本score都大于负样本的假设下，AUC的值为1。</p>
<p> <strong>贝叶斯公式是什么？解释下每一项的含义？</strong> </p>
<p>$P(A|B)&#x3D;\frac{P(B|A)P(A)}{P(B)}$</p>
<p>P(A) 假设事件A发生的先验概率</p>
<p>P(B|A) &#x2F;P(B)    可能性函数</p>
<p>P(A|B)    后验概率，即在B事件发生之后，A事件发生的概率</p>
<p> <strong>大数据组件知道哪些？（Spark，Hadoop，但没用过）</strong> </p>
<p>ZooKeeper，Spark, Neo4j, Hadoop, Hive</p>
<h3 id="1-2-二面-50min"><a href="#1-2-二面-50min" class="headerlink" title="1.2 二面 50min"></a>1.2 二面 50min</h3><h4 id="1-2-1-自我介绍"><a href="#1-2-1-自我介绍" class="headerlink" title="1.2.1 自我介绍"></a>1.2.1 自我介绍</h4><h4 id="1-2-2-Coding"><a href="#1-2-2-Coding" class="headerlink" title="1.2.2 Coding"></a>1.2.2 Coding</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-submatrix-lcci/">最大子矩阵</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-submatrix-lcci/solution/zhe-yao-cong-zui-da-zi-xu-he-shuo-qi-you-jian-dao-/">题解</a></p>
<ul>
<li>最大子序和</li>
</ul>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>dp</p>
<p>状态定义：dp[i] 为以nums[i]结尾的最大子序和</p>
<p>状态转移方程：两种情况，一种是以前一个位置的子序列连着的dp[i] &#x3D; dp[i-1]+nums[i]，另一种是自立门户，从自己开始dp[i]&#x3D;nums[i]</p>
<p>dp[i] &#x3D; max(dp[i-1]+nums[i], nums[i])</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ans = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ; i &lt; nums.<span class="built_in">size</span>() ; i++ )&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">            ans = <span class="built_in">max</span>(dp[i],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>dp[i]只与dp[i-1]和nums[i]有关，所有我们可以将空间复杂度降到O(1)</p>
<p>当dp[i-1]&lt;0时，后者大，反之前者大，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxsum=INT_MIN;</span><br><span class="line">        <span class="type">int</span> dp_i = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span>)</span></span>;<span class="comment">//用来记录答案</span></span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ; i &lt; nums.<span class="built_in">size</span>() ; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( dp_i &gt; <span class="number">0</span> )&#123;    <span class="comment">//dp[i-1] &gt; 0 时</span></span><br><span class="line">                dp_i+=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;              <span class="comment">//dp[i-1]&lt;0时</span></span><br><span class="line">                dp_i=nums[i];</span><br><span class="line">                begin = i;     <span class="comment">//当nums[i]自立门户时候，我们记录下子序列的起始位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp_i &gt; maxsum)&#123;<span class="comment">//更新答案</span></span><br><span class="line">                maxsum = dp_i;</span><br><span class="line">                ans[<span class="number">0</span>] = begin;<span class="comment">//记录下起始和终止位置</span></span><br><span class="line">                ans[<span class="number">1</span>] = i;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>最大子矩阵</li>
</ul>
<p>设数组b表示数组matrix的i～j$(0\leq i \leq j \leq n-1)$行，对应列元素的和，对数组b计算最大子序列和，将二维动态规划问题转化为一维动态规划问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getMaxMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">4</span>)</span></span>;<span class="comment">//保存最大子矩阵的左上角和右下角的行列坐标</span></span><br><span class="line">        <span class="type">int</span> N = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> M = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(M,<span class="number">0</span>)</span></span>;<span class="comment">//记录当前i~j行组成大矩阵的每一列的和，将二维转化为一维</span></span><br><span class="line">        <span class="type">int</span> sum;<span class="comment">//相当于dp[i],dp_i</span></span><br><span class="line">        <span class="type">int</span> maxsum=INT_MIN;<span class="comment">//记录最大值</span></span><br><span class="line">        <span class="type">int</span> bestr1,bestc1;<span class="comment">//暂时记录左上角，相当于begin</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;     <span class="comment">//以i为上边，从上而下扫描</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;M;t++ ) b[t]=<span class="number">0</span>;    <span class="comment">//每次更换子矩形上边，就要清空b，重新计算每列的和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;N;j++)&#123;    <span class="comment">//子矩阵的下边，从i到N-1，不断增加子矩阵的高</span></span><br><span class="line">                <span class="comment">//一下就相当于求一次最大子序列和</span></span><br><span class="line">                sum = <span class="number">0</span>;<span class="comment">//从头开始求dp</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;M;k++)&#123;</span><br><span class="line">                    b[k]+=matrix[j][k];   </span><br><span class="line"><span class="comment">//我们只是不断增加其高，也就是下移矩阵下边，所有这个矩阵每列的和只需要加上新加的哪一行的元素</span></span><br><span class="line"><span class="comment">//因为我们求dp[i]的时候只需要dp[i-1]和nums[i],所有在我们不断更新b数组时就可以求出当前位置的dp_i</span></span><br><span class="line">                    <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        sum+=b[k];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        sum=b[k];</span><br><span class="line">                        bestr1=i;<span class="comment">//自立门户，暂时保存其左上角</span></span><br><span class="line">                        bestc1=k;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>( sum &gt; maxsum)&#123;</span><br><span class="line">                        maxsum = sum;</span><br><span class="line">                        ans[<span class="number">0</span>]=bestr1;<span class="comment">//更新答案</span></span><br><span class="line">                        ans[<span class="number">1</span>]=bestc1;</span><br><span class="line">                        ans[<span class="number">2</span>]=j;</span><br><span class="line">                        ans[<span class="number">3</span>]=k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="1-2-3-概率题"><a href="#1-2-3-概率题" class="headerlink" title="1.2.3 概率题"></a>1.2.3 概率题</h4><p>求期望值 E(min(x1, x2, x3)), x1,x2,x3~U(0, 1)</p>
<p>U(0, 1)    (0,1)均匀分布</p>
<p>(0, 1)内任意长度的三条边a,b,c组成三角形的概率</p>
<h2 id="2-AI-LAB-NLP"><a href="#2-AI-LAB-NLP" class="headerlink" title="2 AI LAB NLP"></a>2 AI LAB NLP</h2><h3 id="2-1-一面"><a href="#2-1-一面" class="headerlink" title="2.1 一面"></a>2.1 一面</h3><h4 id="2-1-1-提问"><a href="#2-1-1-提问" class="headerlink" title="2.1.1 提问"></a>2.1.1 提问</h4><p>你觉得你的项目创新点在哪里</p>
<p>传统的machine learning的[算法]了解哪些？ 你选择一个详细介绍一下（这里面试官说假设他是一个没有接触过这个[算法]的人 如何讲解这个[算法]感觉很考察对[算法]的宏观理解能力）</p>
<h4 id="2-1-2-coding"><a href="#2-1-2-coding" class="headerlink" title="2.1.2 coding"></a>2.1.2 coding</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></p>
<p>历史最低点买进股票。用minprice记录历史最低价格，假设股票在这天买进，那么在第i天卖出股票能得到的利润就是prices[i]-minprice</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">        <span class="type">int</span> minprice = inf, maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price: prices) &#123;</span><br><span class="line">            maxprofit = <span class="built_in">max</span>(maxprofit, price - minprice);</span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-二面"><a href="#2-2-二面" class="headerlink" title="2.2 二面"></a>2.2 二面</h3><h4 id="2-2-1-提问"><a href="#2-2-1-提问" class="headerlink" title="2.2.1 提问"></a>2.2.1 提问</h4><ul>
<li><strong>Word2vec的两种训练目标是什么 其中skip-gram训练的loss function是什么</strong></li>
</ul>
<p><strong>CBOW</strong>（Continuous bag-of-words model)</p>
<p>通过上下文来预测当前值</p>
<p><strong>Skip-gram</strong> (Continuous Skip-gram model)</p>
<p>用当前值预测上下文</p>
<p>word2vec的愿景是希望用一个向量$v_w$表示词$w$，用词之间的内积距离$v_i^Tv_j$表示语义的接近程度，那么条件概率$p(w_{t+j}|w_t)$的定义如下。</p>
<p>$p(W_O|W_I)&#x3D;\frac{exp(V_{wo}^T V_{w_I})}{\sum_{w&#x3D;1}^W exp(V_w^{T}V_{w_I})}$</p>
<p>其中，wo代表wt+j，被称为输出词，wI代表wt，被称为输入词。</p>
<p>损失函数如下</p>
<p><img src="https://pic4.zhimg.com/v2-3baa8ea48cf7028510871a2894ffbb97_r.jpg" alt="v2-3baa8ea48cf7028510871a2894ffbb97_r"></p>
<ul>
<li><strong>L1正则和L2正则说一下 L1满足什么分布</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43786241/article/details/109605265">参考连接</a></p>
<p><strong>L2规范化</strong></p>
<p>增加一个额外的项到代价函数上，这个项被称为规范化项。</p>
<p>$C&#x3D;C_0+\frac{\lambda}{2n}\sum_\omega \omega^2$</p>
<p>满足高斯分布</p>
<p>规范化的效果是让网络倾向于学习小一点的权重</p>
<p><strong>L1规范化</strong></p>
<p>$C&#x3D;C_0+\frac{\lambda}{n}\sum_\omega |\omega|$</p>
<p>满足拉普拉斯分布</p>
<p>当一个特定的权重绝对值$|\omega|$很大时，L1规范化的权重缩小远比L2小很多；当$|\omega|$很小时，L1的缩小比L2大很多。</p>
<h4 id="2-2-2-Coding"><a href="#2-2-2-Coding" class="headerlink" title="2.2.2 Coding"></a>2.2.2 Coding</h4><p>求数组中所有子数组和的最大值 <a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=leetcode">leetcode</a> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></p>
<p>编辑距离 <a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=leetcode">leetcode</a> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></p>
<p>动态规划</p>
<p>给定的两个单词，设为A和B。</p>
<p>对A删除一个字符和对B插入一个字符是等价的。</p>
<p>对A插入一个字符和对B删除一个字符是等价的。</p>
<p>对A替换一个字符和对B替换一个字符是等价的。</p>
<p>本质上不同的操作只有三种：A插入，B插入，A修改</p>
<p>这样以来，我们就可以把原问题转化为规模较小的子问题。我们用 A &#x3D; horse，B &#x3D; ros 作为例子，来看一看是如何把这个问题转化为规模较小的若干子问题的。</p>
<p>在单词 A 中插入一个字符：如果我们知道 horse 到 ro 的编辑距离为 a，那么显然 horse 到 ros 的编辑距离不会超过 a + 1。这是因为我们可以在 a 次操作后将 horse 和 ro 变为相同的字符串，只需要额外的 1 次操作，在单词 A 的末尾添加字符 s，就能在 a + 1 次操作后将 horse 和 ro 变为相同的字符串；</p>
<p>在单词 B 中插入一个字符：如果我们知道 hors 到 ros 的编辑距离为 b，那么显然 horse 到 ros 的编辑距离不会超过 b + 1，原因同上；</p>
<p>修改单词 A 的一个字符：如果我们知道 hors 到 ro 的编辑距离为 c，那么显然 horse 到 ros 的编辑距离不会超过 c + 1，原因同上。</p>
<p>那么从 horse 变成 ros 的编辑距离应该为 min(a + 1, b + 1, c + 1)。</p>
<p>我们用 <code>D[i][j]</code> 表示 <code>A</code> 的前 <code>i</code> 个字母和 <code>B</code> 的前 <code>j</code> 个字母之间的编辑距离。<code>D[i][j-1]</code>，<code>D[i-1][j]</code> 和 <code>D[i-1][j-1]</code> 的值之后就可以计算出 <code>D[i][j]</code>。</p>
<p>状态转移方程如下</p>
<p>若A和B的最后一个字母相同$D[i][j]&#x3D;min(D[i][j-1]+1,D[i-1][j]+1,D[i-1][j-1])&#x3D;1+min(D[i][j-1],D[i-1][j],D[i-1][j-1]-1)$</p>
<p>若A和B的最后一个字母不同</p>
<p>$D[i][j]&#x3D;1+min(D[i][j-1],D[i-1][j],D[i-1][j-1])$</p>
<p>边界情况， <code>D[i][0] = i</code> 和 <code>D[0][j] = j</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = word1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> m = word2.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有一个字符串为空串</span></span><br><span class="line">        <span class="keyword">if</span> (n * m == <span class="number">0</span>) <span class="keyword">return</span> n + m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DP 数组</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">D</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界状态初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            D[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            D[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算所有 DP 值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> left = D[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> down = D[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> left_down = D[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]) left_down += <span class="number">1</span>;</span><br><span class="line">                D[i][j] = <span class="built_in">min</span>(left, <span class="built_in">min</span>(down, left_down));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> D[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">最小的k个数</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            vec[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort 降序排列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), cmp);</span><br></pre></td></tr></table></figure>



<h2 id="3-data-广告算法"><a href="#3-data-广告算法" class="headerlink" title="3 data-广告算法"></a>3 data-广告算法</h2><h3 id="3-1-一面"><a href="#3-1-一面" class="headerlink" title="3.1 一面"></a>3.1 一面</h3><h4 id="3-1-1-提问"><a href="#3-1-1-提问" class="headerlink" title="3.1.1 提问"></a>3.1.1 提问</h4><p>问推荐<a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>的实习，稀疏特征，稠密特征处理，负采样该怎么做，正负样本不均衡等，</p>
<p>  nn模型为什么比xgb效果好</p>
<ul>
<li><strong>transformer：LN和BN</strong></li>
</ul>
<p>某些模型参数会占据较大的优势，甚至是决定性优势，导致模型跑偏，或者是训练速度过于缓慢。</p>
<p><strong>BN</strong>（Batch Normalization）</p>
<p>“批”归一化，对网络中每个层的输入归一化。在训练期间，通过使用当前批中数据的均值和方差来标准化每一层的输入。</p>
<p><img src="https://img-blog.csdnimg.cn/20210228220023518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc4MDg4MA==,size_16,color_FFFFFF,t_70"> </p>
<p>简单的归一化通过限制数据范围减弱或降低了后续激活函数的表达能力。为了克服这些，BN允许网络学习 $\gamma$ 和 $\beta$  参数，让层自主去调整归一化的输入分布，增强表达能力。均值和方差是在每个mini-batch上做的，而 $\gamma$ 和 $\beta$  参数是在整个数据上学习到的。</p>
<p><strong>LN</strong>（Layer Normaliza）</p>
<p>Layer Normaliza是在特征维度进行的归一化。如图，i、j分别是输入数据x两个维度。</p>
<p><img src="https://img-blog.csdnimg.cn/20210228222931495.png" alt="20210228222931495"></p>
<ul>
<li><strong>xgboost相比去gbdt的改进</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/maqunfi/article/details/103404693">参考连接</a></p>
<p>将树模型的复杂度加入到正则项中，参与到损失函数，避免过拟合问题</p>
<p>对损失函数进行优化，优化成二阶泰勒展开形式，加速优化速度。</p>
<p>相比于GBDT只支持Cart作为基分类器的方式，Xgboost还支持线性分类器，在使用线性分类器时候可以使用L1正则化和L2正则化。</p>
<ul>
<li><strong>LR回归：原理，损失</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jk123vip/article/details/80591619">参考链接</a></p>
<p>连续变量预测的定量输出称为回归，离散变量预测的定性输出称为分类</p>
<p><strong>线性回归</strong> （Linear Regression）</p>
<p>学习一条函数$h_\theta(x)&#x3D;\theta_0+\theta_1 x_1 +\theta_2 x_2+…+\theta_n x_n &#x3D; \sum_{i&#x3D;0}^n \theta_ix_i$，使得这个函数尽可能拟合所有观测数据，并希望测试数据也尽可能落在这条线上。</p>
<p><strong>损失函数</strong>，看预测值与实际值之间的均方误差是否最小。定义线性回归损失函数为</p>
<p>$J(\theta)&#x3D;\frac{1}{2m}\sum_{i&#x3D;1}^m(h_\theta(x^i)-y^i)^2$</p>
<p><strong>模型求解方法</strong></p>
<p>最小二乘法，基于均方误差最小化进行模型求解，$\theta&#x3D;(X^TX)^{-1}X^TY$</p>
<p>梯度下降法，$\theta$ 按梯度下降的方法进行减少</p>
<p>$\theta_j :&#x3D; \theta_j - \alpha \frac{\partial}{\partial \theta_j}$</p>
<p>$J(\theta)&#x3D;\theta_j-\alpha \frac{1}{m}\sum_{i&#x3D;1}^m(h_\theta(x^i)-y^i)x_j^i$</p>
<p><strong>逻辑回归</strong>(Logistic Regression)</p>
<p>线性回归完成的是回归拟合任务，对于分类任务，我们同样需要一条线，但不是去拟合每个数据点，而是把不同类别的样本区分开来。</p>
<p>逻辑回归是在线性函数$\theta ^T x$输出预测实际值的基础上，寻找一个假设函数 $h_\theta(x)&#x3D;g(\theta^Tx)$，将实际值映射到0～1之间，如果$h_\theta(x) \geq 0.5$，则预测$y&#x3D;1$，为正例，否则y属于负例。</p>
<p><strong>激活函数</strong></p>
<p>Sigmoid函数，$g(z)&#x3D;\frac{1}{1+e^{-z}}$</p>
<p><strong>损失函数</strong></p>
<p>$J(\theta) &#x3D; -\frac{1}{m}{\sum_{i&#x3D;1}^m y_i log\ h_\theta(x_i) +(1-y_i)log(1-h_\theta(x_i)}$</p>
<p>模型求解方法</p>
<p>梯度下降法，$\theta$ 按梯度下降的方法进行减少</p>
<p>$\theta_j :&#x3D; \theta_j - \alpha \frac{\partial}{\partial \theta_j}$</p>
<p>$J(\theta)&#x3D;\theta_j-\alpha \frac{1}{m}\sum_{i&#x3D;1}^m(h_\theta(x^i)-y^i)x_j^i$</p>
<p>欠拟合，高偏差（bias），没有很好地拟合训练数据，存在较大偏差</p>
<p>过拟合，高方差（variance），对训练数据拟合过好，泛化性能差，上下波动厉害</p>
<p><strong>如果样本中出现重复的样本会出现什么问题（模型鲁棒性）</strong></p>
<p>  <strong>交叉熵的优缺点</strong></p>
<p>交叉熵损失函数</p>
<p>二分类：$L&#x3D;-\frac{1}{N}\sum_i [y_i\ log(p_i)+(1-y_i)\ log(1-p_i)]$</p>
<p>多分类：$L&#x3D;-\frac{1}{N}\sum_i \sum_{c&#x3D;1}^M y_{ic} log(p_{ic})$</p>
<p>- <img src="https://www.zhihu.com/equation?tex=M" alt="[公式]"> ——类别的数量<br>- <img src="https://www.zhihu.com/equation?tex=y_%7Bic%7D" alt="[公式]"> ——符号函数（ <img src="https://www.zhihu.com/equation?tex=0" alt="[公式]"> 或 <img src="https://www.zhihu.com/equation?tex=1" alt="[公式]"> ），如果样本 <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]"> 的真实类别等于 <img src="https://www.zhihu.com/equation?tex=c" alt="[公式]"> 取 <img src="https://www.zhihu.com/equation?tex=1" alt="[公式]"> ，否则取 <img src="https://www.zhihu.com/equation?tex=0" alt="[公式]"><br>- <img src="https://www.zhihu.com/equation?tex=p_%7Bic%7D" alt="[公式]"> ——观测样本 <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]"> 属于类别 <img src="https://www.zhihu.com/equation?tex=c" alt="[公式]"> 的预测概率</p>
<p>优点：<strong>在模型效果差的时候学习速度比较快，效果好的时候学习速度慢</strong>。模型学习的速度取决于学习率和偏导值。学习率是需要设置的超参数，重点关注偏导值。偏导值的大小取决于$x_i$和$[\sigma(s)-y]$，重点关注后者，后者的大小反映了模型的错误程度，该值越大，说明模型效果越差，但该值越大同时也会使得偏导值越大，从而模型的学习速度更快。</p>
<p>缺点：随着分类数目的增大，分类层的线性变化矩阵参数也随着增大；对于封闭集分类问题，学习到的特征是可分离的，但对于开放集人脸识别问题，所学特征却没有足够的区分性。</p>
<p>擅长于学习类间的信息，因为它采用了类间竞争机制，它只关心对于正确标签预测概率的准确性，忽略了其他非正确标签的差异，导致学习到的特征比较散。</p>
<h4 id="3-1-2-Coding"><a href="#3-1-2-Coding" class="headerlink" title="3.1.2 Coding"></a>3.1.2 Coding</h4><p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/restore-ip-addresses/">复原 IP 地址</a></strong></p>
<p><strong>回溯</strong>，对所有可能的字符串分隔方式进行搜索，并筛选出满足要求的作为答案。</p>
<p>设题目中给出的字符串为s，用递归函数dfs(segId, segStart)表示正在从s[segStart]的位置开始，搜索IP地址中的第segId段，其中$segId\in{0,1,2,3}$。由于IP地址的每一段必须是[0,255]中的整数，因此我们从segStart开始，从大到小一次枚举当前一段IP地址的结束位置seg End。如果满足要求，就递归地进行下一段搜索，调用递归函数dfs(segId+1, segEnd+1)。</p>
<p>由于IP地址的每一段不能有前导0，如果s[segStart]等于字符0，那么这一段只能为0。</p>
<p>在搜索的过程中，如果我们已得到全部4段IP地址（segId&#x3D;4），并且遍历完了整个字符串（segStart &#x3D; s.size())，那么就复原出了满足题目要求的IP地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> SEG_COUNT = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; segments;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> segId, <span class="type">int</span> segStart)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></span><br><span class="line">        <span class="keyword">if</span> (segId == SEG_COUNT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (segStart == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                string ipAddr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SEG_COUNT; ++i) &#123;</span><br><span class="line">                    ipAddr += <span class="built_in">to_string</span>(segments[i]);</span><br><span class="line">                    <span class="keyword">if</span> (i != SEG_COUNT - <span class="number">1</span>) &#123;</span><br><span class="line">                        ipAddr += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="built_in">move</span>(ipAddr));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></span><br><span class="line">        <span class="keyword">if</span> (segStart == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></span><br><span class="line">        <span class="keyword">if</span> (s[segStart] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            segments[segId] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(s, segId + <span class="number">1</span>, segStart + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一般情况，枚举每一种可能性并递归</span></span><br><span class="line">        <span class="type">int</span> addr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> segEnd = segStart; segEnd &lt; s.<span class="built_in">size</span>(); ++segEnd) &#123;</span><br><span class="line">            addr = addr * <span class="number">10</span> + (s[segEnd] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (addr &gt; <span class="number">0</span> &amp;&amp; addr &lt;= <span class="number">0xFF</span>) &#123;</span><br><span class="line">                segments[segId] = addr;</span><br><span class="line">                <span class="built_in">dfs</span>(s, segId + <span class="number">1</span>, segEnd + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        segments.<span class="built_in">resize</span>(SEG_COUNT);</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>move 转移，将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.。</p>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></strong></p>
<p><strong>递归</strong></p>
<p>实现一个函数maxGain(node)，计算二叉树中的一个节点的最大贡献值，在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。</p>
<p>计算过程：空节点的最大贡献值等于0；非空节点的最大贡献值等于节点值与其节点中的最大贡献值之和（叶节点的最大贡献值等于节点值）</p>
<p>对于二叉树中的一个节点，该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值，如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和。</p>
<p>全局变量maxSum存储最大路径和。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> maxSum = INT_MIN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxGain</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归计算左右子节点的最大贡献值</span></span><br><span class="line">        <span class="comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line">        <span class="type">int</span> leftGain = <span class="built_in">max</span>(<span class="built_in">maxGain</span>(node-&gt;left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> rightGain = <span class="built_in">max</span>(<span class="built_in">maxGain</span>(node-&gt;right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class="line">        <span class="type">int</span> priceNewpath = node-&gt;val + leftGain + rightGain;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum, priceNewpath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> node-&gt;val + <span class="built_in">max</span>(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maxGain</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache-lcci/">面试题 16.25. LRU 缓存</a></p>
<p>哈希表+双向链表</p>
<p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对时最近使用的，而靠近尾部的键值对时最久未使用的。哈希表通过缓存数据的键映射到其在双向链表中的位置。</p>
<p>首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部。对于get操作，首先判断key是否存在：如果key不存在，返回-1；如果key存在，则key对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。对于put操作，首先判断keky是否存在：如果key不存在，使用key和value创建一个新的节点，在双向链表的头部添加该节点，并将key和该节点添加进哈希表。然后判断双向链表的节点数是否超出容量，若超出容量，则删除双向链表的尾部节点，并删除哈希表中对应项；如果key存在，先通过哈希表定位，再将对应节点的值更新为value，并将该节点移到双向链表的头部。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(): <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(<span class="type">int</span> _key, <span class="type">int</span> _value): <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> _capacity) &#123;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">        capacity = _capacity;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache[key] = node;</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            <span class="built_in">addToHead</span>(node);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode* removed = <span class="built_in">removeTail</span>();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.<span class="built_in">erase</span>(removed-&gt;key);</span><br><span class="line">                <span class="comment">// 防止内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="built_in">addToHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>count函数用以统计key值在unordered_map中出现的次数。实际上，c++ unordered_map不允许有重复的key。因此，如果key存在，则count返回1，如果不存在，则count返回0.</p>
<h4 id="3-1-3-高频算法题整理"><a href="#3-1-3-高频算法题整理" class="headerlink" title="3.1.3 高频算法题整理"></a>3.1.3 高频算法题整理</h4><h5 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h5><p>双指针 + 哈希表。left用来记录重复字符的位置，i用来遍历整个字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>,left = <span class="number">-1</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span> ,<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)&#123;   </span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">find</span>(s[i]) != hash.<span class="built_in">end</span>())&#123;</span><br><span class="line">                left = <span class="built_in">max</span>(hash[s[i]], left);</span><br><span class="line">            &#125;</span><br><span class="line">            hash[s[i]] = i;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>双栈，第一个栈支持插入操作，第二个栈支持删除操作。根据栈先进后出的特性，往第一个栈里插入元素后，将其放置于底部。在执行删除操作时，先看第二栈是否为空，若为空，将第一个栈里的元素一个个弹出插入到第二个栈中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1,stack2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            stack1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            stack2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendTail</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果第二个栈为空</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>());</span><br><span class="line">                stack1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> deleteItem = stack2.<span class="built_in">top</span>();</span><br><span class="line">            stack2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> deleteItem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></strong></p>
<p>二维动态规划</p>
<p>假设字符串text1和text2的长度分别为m和n，创建m+1行n+1列的二位数组dp，其中dp[i][j]表示text1[0:i]和text2[0:j]的最长公共子序列的长度。text1[0:i]表示text1的长度为i的前缀，text2[0:j]表示text2长度为j的前缀。</p>
<p>边界情况：当i为0时，text1[0:i]为空，空字符串和任何字符串的最长公共子序列的长度都是0，因此对任意$0\leq j \leq n$，有dp[0][j]&#x3D;0; 当j&#x3D;0时，对任意$0\leq i \leq m$，有dp[i][0]&#x3D;0。</p>
<p>当i&gt;0且j&gt;0时，考虑dp[i][j]的计算：当text1[i-1]&#x3D;text2[j-1]时，考虑text1[0:i-1]和text2[0:j-1]的最长公共子序列，因此dp[i][j]&#x3D;dp[i-1][j-1]+1;当text1[i-1]$\neq$text2[j-1],dp[i][j]&#x3D;max(dp[i-1][j], dp[i][j-1])</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = text1.<span class="built_in">length</span>(), n = text2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">char</span> c1 = text1.<span class="built_in">at</span>(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="type">char</span> c2 = text2.<span class="built_in">at</span>(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></strong></p>
<p>回溯</p>
<p>设函数check(i, j, k)表示判断以网格的（i，j）位置出发，能否搜索到单词word[k…]，其中word[k…]表示字符串word从第k个字符开始的后缀子串。如果能搜索到，返回true，反之返回false。</p>
<p>check(i, j, k)的执行步骤如下：如果board[i][j]$\neq$s[k]，当前字符不匹配，直接返回false；如果当前已访问到字符串的末尾，且对应字符依然匹配，此时直接返回true；否则，遍历当前位置的所有相邻位置。如果从某个相邻位置出发，能够搜索到子串word[k+1..]，则返回true，否则返回false。</p>
<p>这样，我们对每一个位置(i,j)都调用函数check(i,j,0)进行检查：只要有一处返回true，就说明网格中能够找到相应的单词，否则说明找不到。</p>
<p>为了防止重复遍历相同的位置，需要额外维护一个与board等大的visited数组，用于标识每个位置是否被访问过。每次遍历相邻位置时，需要跳过已被访问的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; visited, <span class="type">int</span> i, <span class="type">int</span> j, string&amp; s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != s[k]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == s.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; directions&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; dir: directions) &#123;</span><br><span class="line">            <span class="type">int</span> newi = i + dir.first, newj = j + dir.second;</span><br><span class="line">            <span class="keyword">if</span> (newi &gt;= <span class="number">0</span> &amp;&amp; newi &lt; board.<span class="built_in">size</span>() &amp;&amp; newj &gt;= <span class="number">0</span> &amp;&amp; newj &lt; board[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[newi][newj]) &#123;</span><br><span class="line">                    <span class="type">bool</span> flag = <span class="built_in">check</span>(board, visited, newi, newj, s, k + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                        result = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h = board.<span class="built_in">size</span>(), w = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visited</span>(h, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(w));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">                <span class="type">bool</span> flag = <span class="built_in">check</span>(board, visited, i, j, word, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h1><h2 id="1-广告"><a href="#1-广告" class="headerlink" title="1 广告"></a>1 广告</h2><h3 id="1-1-一面（70min）"><a href="#1-1-一面（70min）" class="headerlink" title="1.1 一面（70min）"></a>1.1 一面（70min）</h3><h4 id="1-1-1coding"><a href="#1-1-1coding" class="headerlink" title="1.1.1coding"></a>1.1.1coding</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">旋转数组</a>最小值 </p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></strong></li>
</ul>
<p>一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code></p>
<p><img src="https://assets.leetcode-cn.com/solution-static/153/1.png" alt="1"></p>
<p><strong>二分查找</strong></p>
<p>左边界为low，右边界为high，区间中点为pivot。将中点元素nums[pivot] 与右边界元素 nums[high] 进行比较，会出现三种情况</p>
<p>$nums[pivot] &lt; nums[high]$，说明nums[pivot]是最小值右侧的元素。</p>
<p>$nums[pivot] &gt; nums[high]$，说明nums[pivot]是最小值左侧的元素</p>
<p>由于数组不包含重复元素，并且只要当前的区间长度不为1，pivot不会与high重合。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> pivot = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[pivot] &lt; nums[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                low = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为 O*(log*n)</p>
<p>空间复杂度为O(1)</p>
<p>统一使用 <code>while (left &lt; right)</code> ：</p>
<ul>
<li>寻找第一个满足XXX的位置：</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="attribute">if</span> (满足XXX) &#123;</span><br><span class="line">  <span class="attribute">right</span> = middle;</span><br><span class="line">&#125; <span class="section">else</span> &#123;</span><br><span class="line">  <span class="attribute">left</span> = middle + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>寻找最后一个满足XXX的位置：</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int</span> middle = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="attribute">if</span> (满足XXX) &#123;</span><br><span class="line">  <span class="attribute">left</span> = middle;</span><br><span class="line">&#125; <span class="section">else</span> &#123;</span><br><span class="line">  <span class="attribute">right</span> = middle - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a></strong></li>
</ul>
<p>包含重复元素</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/154/1.png" alt="1"></p>
<p>$nums[pivot] &lt; nums[high]$，说明nums[pivot]是最小值右侧的元素。</p>
<p>$nums[pivot] &gt; nums[high]$，说明nums[pivot]是最小值左侧的元素</p>
<p>$nums[pivot] &#x3D; nums[high]$，如下图所示，由于重复元素的存在，我们不能确定nums[pivot]在最小值的哪一侧。由于nums[pivot]与nums[high]的值相同，所以无论nums[high]是不是最小值，都有一个它的替代品nums[pivot]，因此我们可以忽略二分查找区间的右端点。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/154/4.png" alt="4"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> pivot = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[pivot] &lt; nums[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[pivot] &gt; nums[high]) &#123;</span><br><span class="line">                low = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                high -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/46eb436eb6564a62b9f972160e1699c9"><strong>序列和</strong></a></p>
<p>根据等差数列求和公式$S_n&#x3D;a_1n+\frac{n(n-1)}{2}d$，已知d&#x3D;1, Sn&#x3D;N, n替换为i，得到$N&#x3D;a_1i+\frac{i(i-1)}{2}$,由此推得$a_1&#x3D;\frac{2N-(i-1)i}{2i}$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> n;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt;l;</span><br><span class="line">    <span class="type">int</span> i = l;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> b = <span class="built_in">double</span>(<span class="number">2</span>*n - i*(i<span class="number">-1</span>))/(<span class="number">2</span>*i);</span><br><span class="line">        <span class="keyword">if</span>(b &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b-<span class="built_in">long</span>(b) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a = b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">100</span>)    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == i<span class="number">-1</span>)</span><br><span class="line">                cout&lt;&lt; (<span class="built_in">long</span>(a+j));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; (<span class="type">long</span>)(a+j) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-1-2-提问-1"><a href="#1-1-2-提问-1" class="headerlink" title="1.1.2 提问"></a>1.1.2 提问</h4><p>  聊项目，项目背景</p>
<p> Domain Adaptation的实验用了哪些指标（只有F1值） </p>
<p> AUC是多少？AUC的定义？ </p>
<p> 类别不平衡问题是怎么解决的？ </p>
<p> 你做了哪些事情来模型调优，有什么效果？</p>
<p> 有看过具体的分类错误的样本吗？ </p>
<p> 序列推荐和社交推荐结合有什么问题？你们要解决什么问题？ </p>
<h4 id="1-2-真题练习"><a href="#1-2-真题练习" class="headerlink" title="1.2 真题练习"></a>1.2 真题练习</h4><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/f5a3b5ab02ed4202a8b54dfb76ad035e?f=discussion">完美对</a></p>
<p>$a_{i,1}+a_{j,1}&#x3D;a_{i,2}+a_{j,2}&#x3D;a_{i,k}+a_{j,k}$</p>
<p>$a_{i,1}-a_{i,2}&#x3D;a_{j,2}-a_{j,1}$</p>
<p>$a_{i,2}-a_{i,3}&#x3D;a_{j,3}-a_{j,2}$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">num_list</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            cin &gt;&gt; num_list[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; hash_z;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        string z = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string d = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="type">int</span> zi = num_list[i][j] - num_list[i][j + <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> di = num_list[i][j + <span class="number">1</span>] - num_list[i][j];</span><br><span class="line">            z += zi &gt;= <span class="number">0</span> ? <span class="string">&quot;+&quot;</span> + <span class="built_in">to_string</span>(zi) : <span class="built_in">to_string</span>(zi);</span><br><span class="line">            d += di &gt;= <span class="number">0</span> ? <span class="string">&quot;+&quot;</span> + <span class="built_in">to_string</span>(di) : <span class="built_in">to_string</span>(di);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cout &lt;&lt; z &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="keyword">if</span> (hash_z.<span class="built_in">find</span>(d) != hash_z.<span class="built_in">end</span>())</span><br><span class="line">            ans += hash_z[d];</span><br><span class="line">        hash_z[z]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/d03abbd6587d4951a9d2d872e310a3f3">选择物品</a></p>
<p>深度优先遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; tmp, <span class="type">int</span>&amp; n, <span class="type">int</span> m, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = pos; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(ans, tmp, n, m - <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">          <span class="comment">//注意要将tmp中的元素清除</span></span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">dfs</span>(ans, tmp, n, m, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; e : ans)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; q : e)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; q &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/test/question/done?tid=52716123&qid=1664934#summary">小强去春游</a></p>
<p>剩余人数不少于4的时候，比较如下两种操作方案看哪一种用时更少：</p>
<p>1.最轻的人由重到轻每次带过去一个人然后开船回来（为了和方案2对齐，每次也只运2个人）；</p>
<p>2.最轻和次轻的过去，然后最轻的回来让最重的两个过去，次轻的在那边把船再开回来。一共运过去了2个人。</p>
<p>这样一来，人数少于4的时候要么只有最轻的3个人，要么只有最轻的2个人。如果还剩3个人，就让最轻的每次带一个；如果还剩2个人，就直接两个人过河了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,t,a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;=<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=<span class="built_in">min</span>(a[<span class="number">1</span>]*<span class="number">2</span>+a[n<span class="number">-1</span>]+a[n],a[<span class="number">1</span>]+<span class="number">2</span>*a[<span class="number">2</span>]+a[n]);</span><br><span class="line">            n-=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">3</span>)</span><br><span class="line">            ans+=a[<span class="number">1</span>]+a[<span class="number">2</span>]+a[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">            ans+=a[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            ans+=a[<span class="number">1</span>];</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/test/question/done?tid=52716123&qid=1664935#summary">比例问题</a></p>
<p>要求<strong>x</strong>和<strong>y</strong>的乘积最大其实就是要<strong>x</strong>尽可能大（或y尽可能大），因为比例<strong>a&#x2F;b</strong>已经固定了，<strong>y&#x3D;x*b&#x2F;a</strong>, y也随之较大。</p>
<p>先求取<strong>a</strong>和<strong>b</strong>的最大公约数将<strong>a&#x2F;b</strong>化为最简分式，我们可以认为存在一个单元<strong>k</strong>，使得<strong>x&#x3D;a*k</strong>，<strong>y&#x3D;b*k</strong>。</p>
<p>由<strong>x&#x2F;y&#x3D;a&#x2F;b</strong>可知<strong>x&#x2F;a&#x3D;y&#x2F;b</strong>，而<strong>x&#x2F;a&lt;&#x3D;A&#x2F;a</strong>，因此<strong>k&lt;&#x3D;A&#x2F;a</strong>，同理<strong>k&lt;&#x3D;B&#x2F;b</strong>，因此<strong>k</strong>只需要同时满足不大于<strong>A&#x2F;a</strong>和不大于<strong>B&#x2F;b</strong>即可。又因为<strong>x</strong>要尽可能大，所以<strong>k</strong>就要尽可能大，于是得到<strong>k&#x3D;min(A&#x2F;a,B&#x2F;b)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll A,B,a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxFactor</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)    <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">MaxFactor</span>(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;A&gt;&gt;B&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="type">int</span> MaxCom=<span class="built_in">MaxFactor</span>(a,b);</span><br><span class="line">    <span class="type">int</span> simp_a=a/MaxCom,simp_b=b/MaxCom;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    k = <span class="built_in">min</span>(A/simp_a, B/simp_b);</span><br><span class="line">    cout&lt;&lt; k * simp_a &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; k * simp_b &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/test/question/done?tid=52716123&qid=1664936#summary">小强修水渠</a></p>
<p><strong>中位数</strong></p>
<p>水渠位置应该有个约束，必须穿过至少一座房子。由于水渠和y轴平行，所以本题中的y坐标就没有用了，只与x坐标有关。</p>
<p>依题意，不妨设x{0..n-1}是个单调不减的数列，对于<strong>i∈</strong>[0,n)，目标是使∑|xi-x|最小，要x到x0和xn-1的距离和最小，则x一定在x0<del>xn-1中，其到x0和xn-1的距离和均为xn-1-x0，排除掉边缘点x0和xn-1，x1</del>xn-2就满足条件，下面考虑该点还要到x1和xn-2的距离和最小，则x一定在x1~xn-2中……</p>
<p>每次排除掉边缘两个数据点，可以得到x是数列x{0..n-1}的中位数，能够满足到任意一对边缘点的距离和都最小，即距离总和也达到了最小。事实上，使∑|xi-x|最小也是中位数的基本性质。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, y;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; vec[i] &gt;&gt; y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> pos = vec[n/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += <span class="built_in">abs</span>(vec[i] - pos);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/afda747c4d0d414b839b7c37fc5e3baa">国际交流会</a></p>
<p>先将数组进行排序，然后将其分为前后两个子数组，按顺序取出两个子数组的元素组成数对（0-n-1，1-n-2）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; vec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[i] = vec[left];</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp[i] = vec[right];</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += <span class="built_in">abs</span>(tmp[i+<span class="number">1</span>] - tmp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    result += <span class="built_in">abs</span>(tmp[n<span class="number">-1</span>] - tmp[<span class="number">0</span>]);</span><br><span class="line">    cout&lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; tmp[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/test/question/done?tid=52716123&qid=1664938#summary">小强的神奇矩阵</a></p>
<p>动态规划。</p>
<p>采用dpi,j作为选择ai,j作为bj时，求得的最小值。当选择ai,j时，有三种情况，分别为$dp_{0,j}+abs(a_{i,j}-a_{0,j})，dp_{1,j}+abs(a_{i,j}-a_{1,j})，dp_{2,j}+abs(a_{i,j}-a_{2,j})$，因此，得到状态转移方程为</p>
<p>$dp_{i,j}&#x3D;min{dp_{0,j}+abs(a_{i,j}-a_{0,j})，dp_{1,j}+abs(a_{i,j}-a_{1,j})，dp_{2,j}+abs(a_{i,j}-a_{2,j})}$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">a</span>(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[<span class="number">0</span>][j<span class="number">-1</span>]+<span class="built_in">abs</span>(a[i][j]-a[<span class="number">0</span>][j<span class="number">-1</span>]), dp[<span class="number">1</span>][j<span class="number">-1</span>]+<span class="built_in">abs</span>(a[i][j]-a[<span class="number">1</span>][j<span class="number">-1</span>])), dp[<span class="number">2</span>][j<span class="number">-1</span>]+<span class="built_in">abs</span>(a[i][j]-a[<span class="number">2</span>][j<span class="number">-1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[<span class="number">0</span>][n<span class="number">-1</span>], dp[<span class="number">1</span>][n<span class="number">-1</span>]), dp[<span class="number">2</span>][n<span class="number">-1</span>]);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/test/question/done?tid=52716123&qid=1664939#summary">蚂蚁森林之王</a></p>
<p>数组ani存储每个小动物崇拜对象，数组tic存储每个小动物的最高票数，初始化为1（自己可以投给自己）。从右往左遍历，有崇拜对象就把身上的票都投给崇拜对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ani</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tic</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; ani[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ani[i] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tic[ani[i]<span class="number">-1</span>] += tic[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; tic[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/test/question/done?tid=52716123&qid=1664940#summary">删除字符</a></p>
<p>想要字典序小，字符串中的字母应该尽可能满足升序，因此只需遵循一个原则，当前字母的ASCII码不能比前面字母的小，如果出现这种情况，需要把前面的字母删除。注意可能满足升序条件，删除字母的数目还未达到m，此时需继续删除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n , m;</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; c &lt; st[st.<span class="built_in">size</span>()<span class="number">-1</span>] &amp;&amp; m)</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">pop_back</span>();</span><br><span class="line">                m--;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; st.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; st[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt; endl ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/test/question/done?tid=52716123&qid=1664941#summary">视力表</a></p>
<p>多重集排列公式</p>
<p>$\frac{(N\ *\ N)!}{a!\ *\ b!\ * \ c!\ *\ d!}$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> factorial</span><br><span class="line"></span><br><span class="line">n, a, b, c, d = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"><span class="built_in">print</span>(factorial(n*n) // factorial(a) // factorial(b) // factorial(c) // factorial(d) % <span class="number">998244353</span>)</span><br></pre></td></tr></table></figure>

<p>不知道为什么，只能通过3，4个例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="built_in">F</span>(n<span class="number">-1</span>) * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N, a, b, c , d;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = (<span class="type">long</span> <span class="type">long</span>)<span class="built_in">F</span>(N*N)/(<span class="built_in">F</span>(a)*<span class="built_in">F</span>(b)*<span class="built_in">F</span>(c)*<span class="built_in">F</span>(c));</span><br><span class="line">    cout &lt;&lt; result % <span class="number">998244353</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h1><h2 id="1-PCG手游推荐"><a href="#1-PCG手游推荐" class="headerlink" title="1 PCG手游推荐"></a>1 PCG手游推荐</h2><h3 id="1-1-一面-60min"><a href="#1-1-一面-60min" class="headerlink" title="1.1 一面 60min"></a>1.1 一面 60min</h3><h4 id="1-1-1-Coding-20min"><a href="#1-1-1-Coding-20min" class="headerlink" title="1.1.1 Coding 20min"></a>1.1.1 Coding 20min</h4><p><strong>小顶堆+堆<a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a> 20min</strong></p>
<p>解释代码+时间&#x2F;空间复杂度</p>
<p>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子结点的值。如果父亲结点的值大于或等于孩子结点的值，成为大顶堆，否则称为小顶堆。</p>
<ul>
<li>建堆</li>
</ul>
<p>结点按层序存储在数组中，数组i号位表示的结点的左孩子为2i号位，右孩子为(2i+1)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// heap为堆，n为元素个数</span></span><br><span class="line"><span class="type">int</span> heap[maxn],n = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>建堆的过程，是把结点从上往下的调整。总是将当前结点V与它的左右孩子比较（如果有的话），若孩子中存在权值比结点V的权值大的，就将其中权值最大的孩子结点与结点V交换；交换完毕后，继续让结点V和孩子比较，直到结点V的孩子的权值都比结点V的权值小，或者结点V不存在孩子结点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对heap数组在[low,high]范围进行向下调整</span></span><br><span class="line"><span class="comment">// low为欲调整结点的数组下标，high一般为堆的最后一个元素的数组下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downAdjust</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i = low, j = i * <span class="number">2</span>; <span class="comment">//j为其左孩子</span></span><br><span class="line">  <span class="keyword">while</span>(j &lt;= high)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果存在右孩子，且右孩子的值大于左孩子</span></span><br><span class="line">    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; high &amp;&amp; heap[j+<span class="number">1</span>] &gt; heap[j])	j=j+<span class="number">1</span>；</span><br><span class="line">    <span class="comment">// 如果孩子中最大权值比欲调整结点i权值大</span></span><br><span class="line">    <span class="keyword">if</span>(heap[j] &gt; heap[i])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">swap</span>(heap[j],heap[i]);</span><br><span class="line">      i = j;</span><br><span class="line">      j = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      beak;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设序列中元素的个数为n，由于完全二叉树叶子结点个数为n&#x2F;2，下标在[1,n&#x2F;2]范围内的都是非叶子结点。我们可以从n&#x2F;2号位倒着枚举结点，对每个遍历的结点i进行[i,n]范围的调整。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createHeap</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i-- )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">downAdjust</span>(i, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>堆排序</li>
</ul>
<p>直观思路：取出堆顶元素，然后将堆的最后一个元素替换至堆顶，再进行一次针对堆顶元素的向下调整。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">createHeap</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n ; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">swap</span>(heap[i],heap[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">downAdjust</span>(<span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。</p>
<h4 id="1-1-2-提问-2"><a href="#1-1-2-提问-2" class="headerlink" title="1.1.2 提问"></a>1.1.2 提问</h4><p>介绍论文 10min （面试官对Graph不是很感兴趣，没怎么问）<br> 用了视频号和公众号的数据集？<br> 看看效果，上线了吗？（只做了离线评估 ）<br> 评价指标是什么？（ 介绍Baseline，Recall NDCG）</p>
<ul>
<li><strong>如何做特征交叉，有哪些模型？</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1739480">参考博客</a></p>
<p><strong>FM</strong>（Factorization Machines)</p>
<p>一般的线性模型</p>
<p>$y&#x3D;\omega_0+\sum_{i&#x3D;1}^n \omega_ix_i$</p>
<p>为了表述特征间的相关性，采用多项式模型，特征xi与xj的组合用xixj表示，特征对的权值是通过该特征对涉及的两个原始特征的隐向量的内积来计算。</p>
<p>$y&#x3D;\omega_0+\sum_{i&#x3D;1}^n \omega_ix_i+\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;i+1}^n&lt;v_i,v_j&gt;x_ix_j$</p>
<p>FM的优势就是在于对特征组合和维度保证两方面的处理。首先是特征组合，通过对两两特征组合，引入交叉项特征，提高模型得分；其次是应对维度爆炸，通过引入隐向量，完成对特征的参数估计。</p>
<p><strong>FNN</strong></p>
<p>增强FM模型的思路，用FM模型学习到的隐向量初始化深度神经网络模型（MLP），再由MLP完成最终学习。</p>
<p><strong>DeepFM</strong></p>
<p>DeepFM模型是一种可以从原始特征中抽取到各种复杂度特征的端到端模型，包含FM和DNN两部分，FM模型可以抽取low-order特征，DNN可以抽取high-order特征。</p>
<p><strong>为什么需要同时使用高阶和低阶的结果？</strong>在wide&amp;deep的论文中指出是generalization 和 memorization，低阶部分（memorization）主要是从历史数据中，发现item和特征之间的直接相关性，体现准确性；而高阶部分（generalization）主要是从历史数据中发现之前很少出现的或者没有出现的特征组合，体现出新颖性。</p>
<p><strong>为什么FM和DEEP部分要共用embedding层？</strong>因为这样能使得DeepFM从原始的数据输入中学习到低维和高维的特征交叉。</p>
<ul>
<li><strong>normalization方法有哪些？（Batch&#x2F;Layer&#x2F;Instance&#x2F;Group）</strong></li>
</ul>
<p>归一化后，最优解的寻找过程会变得平缓，更容易正确地收敛到最优解。</p>
<p><strong>机器学习</strong></p>
<p><strong>min-max标准化（线性函数归一化）</strong></p>
<p>对原始数据的线性变换，使得结果映射到0-1之间$(x-min)&#x2F;(max-min)$</p>
<p>映射到-1～1，$(x-mean)&#x2F;(max-min)$</p>
<p><strong>Z-socre标准化（0均值标准化）</strong></p>
<p>经过处理的数据符合标准正态分布，即均值为0，标准差为1</p>
<p>$(x-mean)&#x2F;standard \ deviation$</p>
<p>standard deviation为所有样本数据的标准差</p>
<p><strong>MMOE</strong>（没听过）</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0f3e40bfd3ce?utm_campaign=haruki&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">参考链接</a></p>
<p>多任务学习模型，跳出了Shared Bottom将整个隐藏层全部共享的方式，而是将共享层有意识地划分成多个Expert，并引入gate机制，得以个性化组合使用共享层。</p>
<p><strong>PNN（知道名字）</strong></p>
<p>概率神经网络</p>
<p>PNN同样引入了DNN对低阶特征进行组合，但与FNN不同，其并没有单纯使用全连接层来对低阶特征进行组合，而是设计了Product层对特征进行更细致的交叉运算。</p>
<p><strong>DCN（知道名字）</strong></p>
<p>传统DNN对于高阶特征的提取效率并不高，DCN主要特点在于提出Cross network，用于特征的自动化交叉编码。</p>
<p>ONN（没听过）<br>FTRL（推导了公式，为什么能产生稀疏性，是L1的作用吗？）</p>
<h3 id="1-2-二面-60min"><a href="#1-2-二面-60min" class="headerlink" title="1.2 二面 60min"></a>1.2 二面 60min</h3><p><strong>编程</strong>  </p>
<p> 设计模式了解过哪些？（答了单例模式和工厂模式之类的）<br> CPU如何执行函数？<br> 处理特征，逐行处理快？还是按列处理快？</p>
<p><strong>统计</strong><br> 如果有一堆数据和标签，(x, y)要如何建模？<br> 介绍下二项分布和多项式分布？ </p>
<p>  怎么做参数估计？ </p>
<p>  <strong>最优化</strong><br> 有哪些最优化方法（不是DL的优化器）？（GD， SGD，牛顿法） </p>
<p>  牛顿法的二阶导数的逆难以求解，有什么近似方***BFS，原理不懂） </p>
<p>  为什么导数等于0就是极小值？<br> 如果目标函数要收敛，对学习率有什么要求？（不懂） </p>
<p><strong>网络编程</strong><br> TCP 三次握手<br> 线程池如何实现？ </p>
<p>  线程池怎么做分区? </p>
<p>  考虑并发?分段锁? </p>
<p>  <strong>项目</strong><br> 做了什么来调优？（ 模型层面（加参数，调参）+特征层面+数据层面）<br> 数据清洗怎么做？ </p>
<p>  如何预测用户的误点击？</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/03/05/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" rel="prev" title="">
                  <i class="fa fa-chevron-left"></i> 
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/03/05/Maven%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/" rel="next" title="Maven的安装与配置">
                  Maven的安装与配置 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
